<?xml version="1.0" encoding="UTF-8"?>
<SPC5-Config version="1.0.0">
  <application name="ChibiOS/RT Test Suite" version="1.0.0" standalone="true" locked="false">
    <description>Test Specification for ChibiOS/RT.</description>
    <component id="org.chibios.spc5.components.portable.generic_startup">
      <component id="org.chibios.spc5.components.portable.chibios_unitary_tests_engine" />
    </component>
    <instances>
      <instance locked="false" id="org.chibios.spc5.components.portable.generic_startup" />
      <instance locked="false" id="org.chibios.spc5.components.portable.chibios_unitary_tests_engine">
        <description>
          <copyright>
            <value><![CDATA[/*
    ChibiOS - Copyright (C) 2006..2017 Giovanni Di Sirio

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/]]></value>
          </copyright>
          <introduction>
            <value>Test suite for ChibiOS OS Library. The purpose of this suite is to perform unit tests on the library modules and to converge to 100% code coverage through successive improvements.</value>
          </introduction>
        </description>
        <global_data_and_code>
          <code_prefix>
            <value>oslib_</value>
          </code_prefix>
          <global_definitions>
            <value><![CDATA[#define TEST_SUITE_NAME                     "ChibiOS OS Library Test Suite"

/*
 * Allowed delay in timeout checks.
 */
#define ALLOWED_DELAY TIME_MS2I(2)

/*
 * Maximum number of test threads.
 */
#define MAX_THREADS             5

/*
 * Stack size of test threads.
 */
#if defined(CH_ARCHITECTURE_AVR) || defined(CH_ARCHITECTURE_MSP430)
#define THREADS_STACK_SIZE      48
#elif defined(CH_ARCHITECTURE_STM8)
#define THREADS_STACK_SIZE      64
#elif defined(CH_ARCHITECTURE_SIMIA32)
#define THREADS_STACK_SIZE      512
#else
#define THREADS_STACK_SIZE      128
#endif

/*
 * Working Area size of test threads.
 */
#define WA_SIZE MEM_ALIGN_NEXT(THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),	\
                               PORT_WORKING_AREA_ALIGN)

#define TEST_REPORT_HOOK_HEADER test_print_port_info();

extern uint8_t test_buffer[WA_SIZE * 5];
extern thread_t *threads[MAX_THREADS];
extern void * ROMCONST wa[5];

void test_print_port_info(void);
void test_terminate_threads(void);
void test_wait_threads(void);
systime_t test_wait_tick(void);]]></value>
          </global_definitions>
          <global_code>
            <value><![CDATA[void test_print_port_info(void) {

#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
#endif
}

/*
 * Global test buffer holding 5 working areas.
 */
ALIGNED_VAR(PORT_WORKING_AREA_ALIGN) uint8_t test_buffer[WA_SIZE * 5];

/*
 * Pointers to the spawned threads.
 */
thread_t *threads[MAX_THREADS];

/*
 * Pointers to the working areas.
 */
void * ROMCONST wa[5] = {test_buffer + (WA_SIZE * 0),
                         test_buffer + (WA_SIZE * 1),
                         test_buffer + (WA_SIZE * 2),
                         test_buffer + (WA_SIZE * 3),
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
      chThdTerminate(threads[i]);
}

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {

  chThdSleep(1);
  return chVTGetSystemTime();
}]]></value>
          </global_code>
        </global_data_and_code>
        <sequences>
          <sequence>
            <type index="0">
              <value>Internal Tests</value>
            </type>
            <brief>
              <value>Binary Semaphores.</value>
            </brief>
            <description>
              <value>This sequence tests the ChibiOS library functionalities related to binary semaphores.</value>
            </description>
            <condition>
              <value>CH_CFG_USE_SEMAPHORES</value>
            </condition>
            <shared_code>
              <value><![CDATA[#include "ch.h"

static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static THD_FUNCTION(thread2, p) {

  (void)p;
  chThdSleepMilliseconds(50);
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static THD_FUNCTION(thread3, p) {

  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static THD_FUNCTION(thread4, p) {

  chBSemSignal((binary_semaphore_t *)p);
}]]></value>
            </shared_code>
            <cases>
              <case>
                <brief>
                  <value>Semaphore primitives, no state change.</value>
                </brief>
                <description>
                  <value>Wait, Signal and Reset primitives are tested. The testing thread does not trigger a state change.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chSemObjectInit(&sem1, 1);]]></value>
                  </setup_code>
                  <teardown_code>
                    <value><![CDATA[chSemReset(&sem1, 0);]]></value>
                  </teardown_code>
                  <local_variables>
                    <value />
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>The function chSemWait() is invoked, after return the counter and the returned message are tested.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[msg_t msg;

msg = chSemWait(&sem1);
test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
test_assert(MSG_OK == msg, "wrong returned message");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>The function chSemSignal() is invoked, after return the counter is tested.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chSemSignal(&sem1);
test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>The function chSemReset() is invoked, after return the counter is tested.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chSemReset(&sem1, 2);
test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
              <case>
                <brief>
                  <value>Semaphore enqueuing test.</value>
                </brief>
                <description>
                  <value>Five threads with randomized priorities are enqueued to a semaphore then awakened one at time. The test expects that the threads reach their goal in FIFO order or priority order depending on the @p CH_CFG_USE_SEMAPHORES_PRIORITY configuration setting.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chSemObjectInit(&sem1, 0);]]></value>
                  </setup_code>
                  <teardown_code>
                    <value />
                  </teardown_code>
                  <local_variables>
                    <value />
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Five threads are created with mixed priority levels (not increasing nor decreasing). Threads enqueue on a semaphore initialized to zero.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>The semaphore is signaled 5 times. The thread activation sequence is tested.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chSemSignal(&sem1);
chSemSignal(&sem1);
chSemSignal(&sem1);
chSemSignal(&sem1);
chSemSignal(&sem1);
test_wait_threads();
#if CH_CFG_USE_SEMAPHORES_PRIORITY
test_assert_sequence("ADCEB", "invalid sequence");
#else
test_assert_sequence("ABCDE", "invalid sequence");
#endif]]></value>
                    </code>
                  </step>
                </steps>
              </case>
              <case>
                <brief>
                  <value>Semaphore timeout test.</value>
                </brief>
                <description>
                  <value>The three possible semaphore waiting modes (do not wait, wait with timeout, wait without timeout) are explored. The test expects that the semaphore wait function returns the correct value in each of the above scenario and that the semaphore structure status is correct after each operation.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chSemObjectInit(&sem1, 0);]]></value>
                  </setup_code>
                  <teardown_code>
                    <value />
                  </teardown_code>
                  <local_variables>
                    <value><![CDATA[unsigned i;
systime_t target_time;
msg_t msg;]]></value>
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Testing special case TIME_IMMEDIATE.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
test_assert(queue_isempty(&sem1.queue), "queue not empty");
test_assert(sem1.cnt == 0, "counter not zero");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing non-timeout condition.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                               thread2, 0);
msg = chSemWaitTimeout(&sem1, TIME_MS2I(500));
test_wait_threads();
test_assert(msg == MSG_OK, "wrong wake-up message");
test_assert(queue_isempty(&sem1.queue), "queue not empty");
test_assert(sem1.cnt == 0, "counter not zero");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing timeout condition.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[target_time = test_wait_tick() + TIME_MS2I(5 * 50);
for (i = 0; i < 5; i++) {
  test_emit_token('A' + i);
  msg = chSemWaitTimeout(&sem1, TIME_MS2I(50));
  test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
  test_assert(queue_isempty(&sem1.queue), "queue not empty");
  test_assert(sem1.cnt == 0, "counter not zero");
}
test_assert_sequence("ABCDE", "invalid sequence");
test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                        "out of time window");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
              <case>
                <brief>
                  <value>Testing chSemAddCounterI() functionality.</value>
                </brief>
                <description>
                  <value>The functon is tested by waking up a thread then the semaphore counter value is tested.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chSemObjectInit(&sem1, 0);]]></value>
                  </setup_code>
                  <teardown_code>
                    <value />
                  </teardown_code>
                  <local_variables>
                    <value />
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>A thread is created, it goes to wait on the semaphore.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>The semaphore counter is increased by two, it is then tested to be one, the thread must have completed.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chSysLock();
chSemAddCounterI(&sem1, 2);
chSchRescheduleS();
chSysUnlock();
test_wait_threads();
test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
test_assert_sequence("A", "invalid sequence");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
              <case>
                <brief>
                  <value>Testing chSemWaitSignal() functionality.</value>
                </brief>
                <description>
                  <value>This test case explicitly addresses the @p chSemWaitSignal() function. A thread is created that performs a wait and a signal operations. The tester thread is awakened from an atomic wait/signal operation. The test expects that the semaphore wait function returns the correct value in each of the above scenario and that the semaphore structure status is correct after each operation.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chSemObjectInit(&sem1, 0);]]></value>
                  </setup_code>
                  <teardown_code>
                    <value><![CDATA[test_wait_threads();]]></value>
                  </teardown_code>
                  <local_variables>
                    <value />
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>An higher priority thread is created that performs non-atomical wait and signal operations on a semaphore.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>The function chSemSignalWait() is invoked by specifying the same semaphore for the wait and signal phases. The counter value must be one on exit.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chSemSignalWait(&sem1, &sem1);
test_assert(queue_isempty(&sem1.queue), "queue not empty");
test_assert(sem1.cnt == 0, "counter not zero");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>The function chSemSignalWait() is invoked again by specifying the same semaphore for the wait and signal phases. The counter value must be one on exit.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chSemSignalWait(&sem1, &sem1);
test_assert(queue_isempty(&sem1.queue), "queue not empty");
test_assert(sem1.cnt == 0, "counter not zero");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
              <case>
                <brief>
                  <value>Testing Binary Semaphores special case.</value>
                </brief>
                <description>
                  <value>This test case tests the binary semaphores functionality. The test both checks the binary semaphore status and the expected status of the underlying counting semaphore.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value />
                  </setup_code>
                  <teardown_code>
                    <value><![CDATA[test_wait_threads();]]></value>
                  </teardown_code>
                  <local_variables>
                    <value><![CDATA[binary_semaphore_t bsem;
msg_t msg;]]></value>
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Creating a binary semaphore in "taken" state, the state is checked.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chBSemObjectInit(&bsem, true);
test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Resetting the binary semaphore in "taken" state, the state must not change.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chBSemReset(&bsem, true);
test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Starting a signaler thread at a lower priority.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
                               chThdGetPriorityX()-1, thread4, &bsem);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Waiting for the binary semaphore to be signaled, the semaphore is expected to be taken.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[msg = chBSemWait(&bsem);
test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
test_assert(msg == MSG_OK, "unexpected message");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Signaling the binary semaphore, checking the binary semaphore state to be "not taken" and the underlying counter semaphore counter to be one.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chBSemSignal(&bsem);
test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Signaling the binary semaphore again, the internal state must not change from "not taken".</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chBSemSignal(&bsem);
test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
            </cases>
          </sequence>
          <sequence>
            <type index="0">
              <value>Internal Tests</value>
            </type>
            <brief>
              <value>Mailboxes.</value>
            </brief>
            <description>
              <value>This sequence tests the ChibiOS libraryfunctionalities related to mailboxes.</value>
            </description>
            <condition>
              <value>CH_CFG_USE_MAILBOXES</value>
            </condition>
            <shared_code>
              <value><![CDATA[#define MB_SIZE 4

static msg_t mb_buffer[MB_SIZE];
static MAILBOX_DECL(mb1, mb_buffer, MB_SIZE);]]></value>
            </shared_code>
            <cases>
              <case>
                <brief>
                  <value>Mailbox normal API, non-blocking tests.</value>
                </brief>
                <description>
                  <value>The mailbox normal API is tested without triggering blocking conditions.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chMBObjectInit(&mb1, mb_buffer, MB_SIZE);]]></value>
                  </setup_code>
                  <teardown_code>
                    <value><![CDATA[chMBReset(&mb1);]]></value>
                  </teardown_code>
                  <local_variables>
                    <value><![CDATA[msg_t msg1, msg2;
unsigned i;]]></value>
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Testing the mailbox size.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Resetting the mailbox, conditions are checked, no errors expected.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chMBReset(&mb1);
test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing the behavior of API when the mailbox is in reset state then return in active state.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[msg1 = chMBPostTimeout(&mb1, (msg_t)0, TIME_INFINITE);
test_assert(msg1 == MSG_RESET, "not in reset state");
msg1 = chMBPostAheadTimeout(&mb1, (msg_t)0, TIME_INFINITE);
test_assert(msg1 == MSG_RESET, "not in reset state");
msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
test_assert(msg1 == MSG_RESET, "not in reset state");
chMBResumeX(&mb1);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Filling the mailbox using chMBPostTimeout() and chMBPostAheadTimeout() once, no errors expected.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MB_SIZE - 1; i++) {
  msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  test_assert(msg1 == MSG_OK, "wrong wake-up message");
}
msg1 = chMBPostAheadTimeout(&mb1, 'A', TIME_INFINITE);
test_assert(msg1 == MSG_OK, "wrong wake-up message");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing intermediate conditions. Data pointers must be aligned, semaphore counters are checked.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Emptying the mailbox using chMBFetchTimeout(), no errors expected.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MB_SIZE; i++) {
  msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
  test_assert(msg1 == MSG_OK, "wrong wake-up message");
  test_emit_token(msg2);
}
test_assert_sequence("ABCD", "wrong get sequence");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Posting and then fetching one more message, no errors expected.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
test_assert(msg1 == MSG_OK, "wrong wake-up message");
msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
test_assert(msg1 == MSG_OK, "wrong wake-up message");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing final conditions. Data pointers must be aligned to buffer start, semaphore counters are checked.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
              <case>
                <brief>
                  <value>Mailbox I-Class API, non-blocking tests.</value>
                </brief>
                <description>
                  <value>The mailbox I-Class API is tested without triggering blocking conditions.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chMBObjectInit(&mb1, mb_buffer, MB_SIZE);]]></value>
                  </setup_code>
                  <teardown_code>
                    <value><![CDATA[chMBReset(&mb1);]]></value>
                  </teardown_code>
                  <local_variables>
                    <value><![CDATA[msg_t msg1, msg2;
unsigned i;]]></value>
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Testing the mailbox size.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Resetting the mailbox, conditions are checked, no errors expected. The mailbox is then returned in active state.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chSysLock();
chMBResetI(&mb1);
chSysUnlock();
test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
chMBResumeX(&mb1);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Filling the mailbox using chMBPostI() and chMBPostAheadI() once, no errors expected.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MB_SIZE - 1; i++) {
  chSysLock();
  msg1 = chMBPostI(&mb1, 'B' + i);
  chSysUnlock();
  test_assert(msg1 == MSG_OK, "wrong wake-up message");
}
chSysLock();
msg1 = chMBPostAheadI(&mb1, 'A');
chSysUnlock();
test_assert(msg1 == MSG_OK, "wrong wake-up message");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing intermediate conditions. Data pointers must be aligned, semaphore counters are checked.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Emptying the mailbox using chMBFetchI(), no errors expected.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MB_SIZE; i++) {
  chSysLock();
  msg1 = chMBFetchI(&mb1, &msg2);
  chSysUnlock();
  test_assert(msg1 == MSG_OK, "wrong wake-up message");
  test_emit_token(msg2);
}
test_assert_sequence("ABCD", "wrong get sequence");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Posting and then fetching one more message, no errors expected.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
test_assert(msg1 == MSG_OK, "wrong wake-up message");
msg1 = chMBFetchTimeout(&mb1, &msg2, TIME_INFINITE);
test_assert(msg1 == MSG_OK, "wrong wake-up message");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing final conditions. Data pointers must be aligned to buffer start, semaphore counters are checked.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
              <case>
                <brief>
                  <value>Mailbox timeouts.</value>
                </brief>
                <description>
                  <value>The mailbox API is tested for timeouts.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chMBObjectInit(&mb1, mb_buffer, MB_SIZE);]]></value>
                  </setup_code>
                  <teardown_code>
                    <value><![CDATA[chMBReset(&mb1);]]></value>
                  </teardown_code>
                  <local_variables>
                    <value><![CDATA[msg_t msg1, msg2;
unsigned i;]]></value>
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Filling the mailbox.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MB_SIZE; i++) {
  msg1 = chMBPostTimeout(&mb1, 'B' + i, TIME_INFINITE);
  test_assert(msg1 == MSG_OK, "wrong wake-up message");
}]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing chMBPostTimeout(), chMBPostI(), chMBPostAheadTimeout() and chMBPostAheadI() timeout.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[msg1 = chMBPostTimeout(&mb1, 'X', 1);
test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
chSysLock();
msg1 = chMBPostI(&mb1, 'X');
chSysUnlock();
test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
msg1 = chMBPostAheadTimeout(&mb1, 'X', 1);
test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
chSysLock();
msg1 = chMBPostAheadI(&mb1, 'X');
chSysUnlock();
test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Resetting the mailbox. The mailbox is then returned in active state.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chMBReset(&mb1);
chMBResumeX(&mb1);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing chMBFetchTimeout() and chMBFetchI() timeout.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[msg1 = chMBFetchTimeout(&mb1, &msg2, 1);
test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
chSysLock();
msg1 = chMBFetchI(&mb1, &msg2);
chSysUnlock();
test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
            </cases>
          </sequence>
          <sequence>
            <type index="0">
              <value>Internal Tests</value>
            </type>
            <brief>
              <value>Memory Pools.</value>
            </brief>
            <description>
              <value>This sequence tests the ChibiOS  library functionalities related to memory pools.</value>
            </description>
            <condition>
              <value>CH_CFG_USE_MEMPOOLS</value>
            </condition>
            <shared_code>
              <value><![CDATA[#define MEMORY_POOL_SIZE 4

static uint32_t objects[MEMORY_POOL_SIZE];
static MEMORYPOOL_DECL(mp1, sizeof (uint32_t), PORT_NATURAL_ALIGN, NULL);

#if CH_CFG_USE_SEMAPHORES
static GUARDEDMEMORYPOOL_DECL(gmp1, sizeof (uint32_t), PORT_NATURAL_ALIGN);
#endif

static void *null_provider(size_t size, unsigned align) {

  (void)size;
  (void)align;

  return NULL;
}]]></value>
            </shared_code>
            <cases>
              <case>
                <brief>
                  <value>Loading and emptying a memory pool.</value>
                </brief>
                <description>
                  <value>The memory pool functionality is tested by loading and emptying it, all conditions are tested.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chPoolObjectInit(&mp1, sizeof (uint32_t), NULL);]]></value>
                  </setup_code>
                  <teardown_code>
                    <value />
                  </teardown_code>
                  <local_variables>
                    <value><![CDATA[unsigned i;]]></value>
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Adding the objects to the pool using chPoolLoadArray().</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Emptying the pool using chPoolAlloc().</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MEMORY_POOL_SIZE; i++)
  test_assert(chPoolAlloc(&mp1) != NULL, "list empty");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Now must be empty.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Adding the objects to the pool using chPoolFree().</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MEMORY_POOL_SIZE; i++)
  chPoolFree(&mp1, &objects[i]);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Emptying the pool using chPoolAlloc() again.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MEMORY_POOL_SIZE; i++)
  test_assert(chPoolAlloc(&mp1) != NULL, "list empty");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Now must be empty again.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Covering the case where a provider is unable to return more memory.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
              <case>
                <brief>
                  <value>Loading and emptying a guarded memory pool without waiting.</value>
                </brief>
                <description>
                  <value>The memory pool functionality is tested by loading and emptying it, all conditions are tested.</value>
                </description>
                <condition>
                  <value>CH_CFG_USE_SEMAPHORES</value>
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));]]></value>
                  </setup_code>
                  <teardown_code>
                    <value />
                  </teardown_code>
                  <local_variables>
                    <value><![CDATA[unsigned i;]]></value>
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Adding the objects to the pool using chGuardedPoolLoadArray().</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Emptying the pool using chGuardedPoolAllocTimeout().</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MEMORY_POOL_SIZE; i++)
  test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Now must be empty.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Adding the objects to the pool using chGuardedPoolFree().</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MEMORY_POOL_SIZE; i++)
  chGuardedPoolFree(&gmp1, &objects[i]);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Emptying the pool using chGuardedPoolAllocTimeout() again.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[for (i = 0; i < MEMORY_POOL_SIZE; i++)
  test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Now must be empty again.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
              <case>
                <brief>
                  <value>Guarded Memory Pools timeout.</value>
                </brief>
                <description>
                  <value>The timeout features for the Guarded Memory Pools is tested.</value>
                </description>
                <condition>
                  <value>CH_CFG_USE_SEMAPHORES</value>
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));]]></value>
                  </setup_code>
                  <teardown_code>
                    <value />
                  </teardown_code>
                  <local_variables>
                    <value />
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Trying to allocate with 100mS timeout, must fail because the pool is empty.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_MS2I(100)) == NULL, "list not empty");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
            </cases>
          </sequence>
          <sequence>
            <type index="0">
              <value>Internal Tests</value>
            </type>
            <brief>
              <value>Memory Heaps.</value>
            </brief>
            <description>
              <value>This sequence tests the ChibiOS library functionalities related to memory heaps.</value>
            </description>
            <condition>
              <value>CH_CFG_USE_HEAP</value>
            </condition>
            <shared_code>
              <value><![CDATA[#define ALLOC_SIZE 16
#define HEAP_SIZE (ALLOC_SIZE * 8)

memory_heap_t test_heap;]]></value>
            </shared_code>
            <cases>
              <case>
                <brief>
                  <value>Allocation and fragmentation.</value>
                </brief>
                <description>
                  <value>Series of allocations/deallocations are performed in carefully designed sequences in order to stimulate all the possible code paths inside the allocator. The test expects to find the heap back to the initial status after each sequence.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value><![CDATA[chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));]]></value>
                  </setup_code>
                  <teardown_code>
                    <value />
                  </teardown_code>
                  <local_variables>
                    <value><![CDATA[void *p1, *p2, *p3;
size_t n, sz;]]></value>
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Testing initial conditions, the heap must not be fragmented and one free block present.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Trying to allocate an block bigger than available space, an error is expected.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[p1 = chHeapAlloc(&test_heap, sizeof test_buffer * 2);
test_assert(p1 == NULL, "allocation not failed");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Single block allocation using chHeapAlloc() then the block is freed using chHeapFree(), must not fail.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
test_assert(p1 != NULL, "allocation failed");
chHeapFree(p1);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Using chHeapStatus() to assess the heap state. There must be at least one free block of sufficient size.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[size_t total_size, largest_size;

n = chHeapStatus(&test_heap, &total_size, &largest_size);
test_assert(n == 1, "missing free block");
test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
test_assert(total_size == largest_size, "unexpected heap state");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Allocating then freeing in the same order.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
chHeapFree(p1);                                 /* Does not merge.*/
chHeapFree(p2);                                 /* Merges backward.*/
chHeapFree(p3);                                 /* Merges both sides.*/
test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Allocating then freeing in reverse order.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
chHeapFree(p3);                                 /* Merges forward.*/
chHeapFree(p2);                                 /* Merges forward.*/
chHeapFree(p1);                                 /* Merges forward.*/
test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Small fragments handling. Checking the behavior when allocating blocks with size not multiple of alignment unit.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[p1 = chHeapAlloc(&test_heap, ALLOC_SIZE + 1);
p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
chHeapFree(p1);
test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
/* Note, the first situation happens when the alignment size is smaller
   than the header size, the second in the other cases.*/
test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
            (chHeapStatus(&test_heap, &n, NULL) == 2), "heap fragmented");
chHeapFree(p2);
chHeapFree(p1);
test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Skipping a fragment, the first fragment in the list is too small so the allocator must pick the second one.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
chHeapFree(p1);
test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
p1 = chHeapAlloc(&test_heap, ALLOC_SIZE * 2); /* Skips first fragment.*/
chHeapFree(p1);
chHeapFree(p2);
test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Allocating the whole available space.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[(void)chHeapStatus(&test_heap, &n, NULL);
p1 = chHeapAlloc(&test_heap, n);
test_assert(p1 != NULL, "allocation failed");
test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
chHeapFree(p1);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing final conditions. The heap geometry must be the same than the one registered at beginning.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
test_assert(n == sz, "size changed");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
              <case>
                <brief>
                  <value>Default Heap.</value>
                </brief>
                <description>
                  <value>The default heap is pre-allocated in the system. We test base functionality.</value>
                </description>
                <condition>
                  <value />
                </condition>
                <various_code>
                  <setup_code>
                    <value />
                  </setup_code>
                  <teardown_code>
                    <value />
                  </teardown_code>
                  <local_variables>
                    <value><![CDATA[void *p1;
size_t total_size, largest_size;]]></value>
                  </local_variables>
                </various_code>
                <steps>
                  <step>
                    <description>
                      <value>Single block allocation using chHeapAlloc() then the block is freed using chHeapFree(), must not fail.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[(void)chHeapStatus(NULL, &total_size, &largest_size);
p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
test_assert(p1 != NULL, "allocation failed");
chHeapFree(p1);]]></value>
                    </code>
                  </step>
                  <step>
                    <description>
                      <value>Testing allocation failure.</value>
                    </description>
                    <tags>
                      <value />
                    </tags>
                    <code>
                      <value><![CDATA[p1 = chHeapAlloc(NULL, (size_t)-256);
test_assert(p1 == NULL, "allocation not failed");]]></value>
                    </code>
                  </step>
                </steps>
              </case>
            </cases>
          </sequence>
        </sequences>
      </instance>
    </instances>
    <exportedFeatures />
  </application>
</SPC5-Config>
